#!/usr/bin/env python3
"""
Reproduce polarization map figures from saved NPZ files.

This script loads NPZ files generated by plot_polarization_maps.py and
recreates the exact same figures with the same styling and layout.
"""

import numpy as np
import matplotlib.pyplot as plt
import os
import sys
import argparse
from pathlib import Path
import glob

import matplotlib as mpl
mpl.rcParams.update({
    "text.usetex": False,          # use MathText (portable)
    "font.family": "STIXGeneral",  # match math fonts
    "font.size": 12,
    "mathtext.fontset": "stix",
    "axes.unicode_minus": False,   # proper minus sign
})


def load_npz_frame(npz_path):
    """
    Load a single NPZ frame file.
    
    Parameters:
    -----------
    npz_path : str
        Path to the NPZ file
        
    Returns:
    --------
    dict : Dictionary containing all loaded data
    """
    if not os.path.exists(npz_path):
        raise FileNotFoundError(f"NPZ file not found: {npz_path}")
    
    data = np.load(npz_path, allow_pickle=True)
    
    # Extract data into a dictionary
    result = {}
    for key in data.keys():
        value = data[key]
        
        # Handle string fields (regime) - check first before numeric conversion
        if key == 'regime':
            if isinstance(value, np.ndarray):
                if value.dtype == object:
                    result[key] = str(value.item())
                elif value.dtype.kind in ['U', 'S']:  # String type
                    result[key] = str(value.item()) if value.size == 1 else str(value)
                else:
                    result[key] = str(value)
            else:
                result[key] = str(value)
        # Handle tuple arrays (bounds)
        elif key in ['screen_bounds', 'emit_bounds']:
            if isinstance(value, np.ndarray):
                if value.dtype == object:
                    result[key] = tuple(value.item())
                else:
                    result[key] = tuple(value)
            else:
                result[key] = tuple(value) if hasattr(value, '__iter__') else value
        # Handle scalar arrays (numeric values)
        elif isinstance(value, np.ndarray) and value.size == 1:
            # Check if it's a string type before converting to float
            if value.dtype.kind in ['U', 'S']:  # Unicode string or byte string
                result[key] = str(value.item())
            elif value.dtype == object:
                # Try to extract the item, but be careful with strings
                item = value.item()
                if isinstance(item, str):
                    result[key] = item
                else:
                    result[key] = item
            else:
                # Numeric type - safe to convert to float
                result[key] = float(value)
        # Handle 2D arrays (polarization maps) and other arrays
        else:
            result[key] = value
    
    return result


def reproduce_frame_from_npz(npz_path, output_path=None, show_plot=False):
    """
    Reproduce a single frame from an NPZ file.
    
    Parameters:
    -----------
    npz_path : str
        Path to the NPZ file
    output_path : str, optional
        Path to save the reproduced figure. If None, saves in same directory as NPZ.
    show_plot : bool
        If True, display the plot (default: False)
    """
    print(f"Loading NPZ file: {npz_path}")
    data = load_npz_frame(npz_path)
    # print

    # Extract polarization maps
    P_separated = data['P_separated']
    P_mixed = data['P_mixed']



    import time

    time.sleep(1)
    print("|P_separated|: ", np.min(np.abs(P_separated)), np.max(np.abs(P_separated)))
    print("Re(P_separated): ", np.min(np.real(P_separated)), np.max(np.real(P_separated)))
    print("Im(P_separated): ", np.min(np.imag(P_separated)), np.max(np.imag(P_separated)))

    print("|P_mixed|: ", np.min(np.abs(P_mixed)), np.max(np.abs(P_mixed)))
    print("Re(P_mixed): ", np.min(np.real(P_mixed)), np.max(np.real(P_mixed)))
    print("Im(P_mixed): ", np.min(np.imag(P_mixed)), np.max(np.imag(P_mixed)))
    print("--------------------------------")
    return
    # plot 1x1: np.abs(P_separated)
    # plot 1x2: np.real(P_separated)
    # plot 1x3: np.imag(P_separated)
    # plot 2x1: np.abs(P_mixed)
    # plot 2x2: np.real(P_mixed)
    # plot 2x3: np.imag(P_mixed)
    

    # Extract chi values
    chi_separated = data['chi_separated']
    chi_mixed = data.get('chi_mixed', chi_separated)  # Fallback if not present
    
    # Determine regime and color
    if chi_separated < 1.0:
        regime = "Synchrotron-dominated"
        regime_color = 'green'
    elif chi_separated < 3.0:
        regime = "Transitional"
        regime_color = 'yellow'
    else:
        regime = "Faraday-dominated"
        regime_color = 'red'
    
    # Create figure with subplots (same layout as original)
    fig, axes = plt.subplots(2, 3, figsize=(17.7777777778, 10))
    
    title = f'Polarization Maps Comparison ($\\chi = {chi_separated:.3f}$) - {regime}'
    fig.suptitle(title, fontsize=28, fontweight='bold', color=regime_color)
    
    # Modern colormaps - same as original
    cmap_magnitude = 'turbo'  # Modern rainbow colormap
    cmap_complex = 'seismic'   # Modern alternative to RdBu_r
    
    # Plot 1: Separated - Magnitude
    im1 = axes[0, 0].imshow(np.abs(P_separated), origin='lower', cmap=cmap_magnitude, aspect='auto')
    axes[0, 0].set_title('Separated: $|P|$ (Magnitude)', fontsize=24, fontweight='bold')
    axes[0, 0].set_xlabel('$X$', fontsize=20)
    axes[0, 0].set_ylabel('$Y$', fontsize=20)
    axes[0, 0].tick_params(labelsize=18)
    cbar1 = plt.colorbar(im1, ax=axes[0, 0])
    cbar1.set_label('$|P|$', fontsize=20)
    cbar1.ax.tick_params(labelsize=18)
    
    # Plot 2: Separated - Real part
    im2 = axes[0, 1].imshow(np.real(P_separated), origin='lower', cmap=cmap_complex, aspect='auto')
    axes[0, 1].set_title('Separated: $\\mathrm{Re}(P)$', fontsize=24, fontweight='bold')
    axes[0, 1].set_xlabel('$X$', fontsize=20)
    axes[0, 1].set_ylabel('$Y$', fontsize=20)
    axes[0, 1].tick_params(labelsize=18)
    cbar2 = plt.colorbar(im2, ax=axes[0, 1])
    cbar2.set_label('$\\mathrm{Re}(P)$', fontsize=20)
    cbar2.ax.tick_params(labelsize=18)
    
    # Plot 3: Separated - Imaginary part
    im3 = axes[0, 2].imshow(np.imag(P_separated), origin='lower', cmap=cmap_complex, aspect='auto')
    axes[0, 2].set_title('Separated: $\\mathrm{Im}(P)$', fontsize=24, fontweight='bold')
    axes[0, 2].set_xlabel('$X$', fontsize=20)
    axes[0, 2].set_ylabel('$Y$', fontsize=20)
    axes[0, 2].tick_params(labelsize=18)
    cbar3 = plt.colorbar(im3, ax=axes[0, 2])
    cbar3.set_label('$\\mathrm{Im}(P)$', fontsize=20)
    cbar3.ax.tick_params(labelsize=18)
    
    # Plot 4: Mixed - Magnitude
    im4 = axes[1, 0].imshow(np.abs(P_mixed), origin='lower', cmap=cmap_magnitude, aspect='auto')
    axes[1, 0].set_title('Mixed: $|P|$ (Magnitude)', fontsize=24, fontweight='bold')
    axes[1, 0].set_xlabel('$X$', fontsize=20)
    axes[1, 0].set_ylabel('$Y$', fontsize=20)
    axes[1, 0].tick_params(labelsize=18)
    cbar4 = plt.colorbar(im4, ax=axes[1, 0])
    cbar4.set_label('$|P|$', fontsize=20)
    cbar4.ax.tick_params(labelsize=18)
    
    # Plot 5: Mixed - Real part
    im5 = axes[1, 1].imshow(np.real(P_mixed), origin='lower', cmap=cmap_complex, aspect='auto')
    axes[1, 1].set_title('Mixed: $\\mathrm{Re}(P)$', fontsize=24, fontweight='bold')
    axes[1, 1].set_xlabel('$X$', fontsize=20)
    axes[1, 1].set_ylabel('$Y$', fontsize=20)
    axes[1, 1].tick_params(labelsize=18)
    cbar5 = plt.colorbar(im5, ax=axes[1, 1])
    cbar5.set_label('$\\mathrm{Re}(P)$', fontsize=20)
    cbar5.ax.tick_params(labelsize=18)
    
    # Plot 6: Mixed - Imaginary part
    im6 = axes[1, 2].imshow(np.imag(P_mixed), origin='lower', cmap=cmap_complex, aspect='auto')
    axes[1, 2].set_title('Mixed: $\\mathrm{Im}(P)$', fontsize=24, fontweight='bold')
    axes[1, 2].set_xlabel('$X$', fontsize=20)
    axes[1, 2].set_ylabel('$Y$', fontsize=20)
    axes[1, 2].tick_params(labelsize=18)
    cbar6 = plt.colorbar(im6, ax=axes[1, 2])
    cbar6.set_label('$\\mathrm{Im}(P)$', fontsize=20)
    cbar6.ax.tick_params(labelsize=18)
    
    plt.tight_layout()
    
    # Determine output path
    if output_path is None:
        # Save in same directory as NPZ, with "_reproduced" suffix
        npz_dir = os.path.dirname(npz_path)
        npz_basename = os.path.basename(npz_path)
        output_basename = npz_basename.replace('.npz', '_reproduced.png')
        output_path = os.path.join(npz_dir, output_basename)
    
    # Save the figure
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    print(f"Saved reproduced figure to: {output_path}")
    
    # if show_plot:
    #     plt.show()
    # else:
    #     plt.close()
    
    return fig


def reproduce_all_frames(npz_dir, output_dir=None, pattern="frame_*.npz", show_plot=False):
    """
    Reproduce all NPZ frames in a directory.
    
    Parameters:
    -----------
    npz_dir : str
        Directory containing NPZ files
    output_dir : str, optional
        Directory to save reproduced figures. If None, saves in npz_dir.
    pattern : str
        Glob pattern to match NPZ files (default: "frame_*.npz")
    show_plot : bool
        If True, display each plot (default: False)
    """
    npz_dir = os.path.abspath(npz_dir)
    
    # Find all NPZ files
    npz_files = sorted(glob.glob(os.path.join(npz_dir, pattern)))

    if len(npz_files) == 0:
        print(f"No NPZ files found in {npz_dir} matching pattern '{pattern}'")
        return
    
    print(f"Found {len(npz_files)} NPZ files to reproduce")
    
    # Set output directory
    if output_dir is None:
        output_dir = npz_dir
    else:
        os.makedirs(output_dir, exist_ok=True)
    
    # Reproduce each frame
    for i, npz_path in enumerate(npz_files):
        npz_basename = os.path.basename(npz_path)
        output_basename = npz_basename.replace('.npz', '_reproduced.png')
        output_path = os.path.join(output_dir, output_basename)
        
        print(f"\n[{i+1}/{len(npz_files)}] Processing: {npz_basename}")
        try:
            reproduce_frame_from_npz(npz_path, output_path, show_plot=show_plot)
        except Exception as e:
            print(f"  Error reproducing {npz_basename}: {e}")
            continue
    
    print(f"\n\nCompleted! Reproduced {len(npz_files)} figures")
    print(f"Figures saved in: {output_dir}")


def main():
    """Main function to run the reproduction script."""
    parser = argparse.ArgumentParser(
        description="Reproduce polarization map figures from NPZ files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Reproduce a single frame
  python reproduce_polarization_maps.py --npz frame_0001_chi_0.003.npz
  
  # Reproduce all frames in a directory
  python reproduce_polarization_maps.py --dir compare_measures/lp2016_outputs/animation_frames3
  
  # Reproduce with custom output directory
  python reproduce_polarization_maps.py --dir frames/ --output_dir reproduced_frames/
        """
    )
    npz=r"D:\Рабочая папка\GitHub\AstroTurbulence\compare_measures\lp2016_outputs\animation_frames3\frame_0000_chi_0.003.npz"
    dir_name=r"D:\Рабочая папка\GitHub\AstroTurbulence\compare_measures\lp2016_outputs\animation_frames3"
    reproduce_name=r"D:\Рабочая папка\GitHub\AstroTurbulence\compare_measures\lp2016_outputs\animation_frames3\reproduce"
    pattern="frame_*.npz"
    show="store_true"

    # parser.add_argument("--npz", type=str, default=None,
    #                     help="Path to a single NPZ file to reproduce")
    # parser.add_argument("--dir", type=str, default=None,
    #                     help="Directory containing NPZ files to reproduce")
    # parser.add_argument("--output", type=str, default=None,
    #                     help="Output path for single frame, or output directory for batch mode")
    # parser.add_argument("--pattern", type=str, default="frame_*.npz",
    #                     help="Glob pattern for NPZ files (default: 'frame_*.npz')")
    # parser.add_argument("--show", action="store_true",
    #                     help="Display plots (default: False)")
    
    # args = parser.parse_args()

    reproduce_all_frames(dir_name, reproduce_name, pattern, show_plot="False")

    
    # if args.npz is not None:
    #     # Single file mode
    #     reproduce_frame_from_npz(args.npz, args.output, show_plot=args.show)
    # elif args.dir is not None:
    #     # Batch mode
    #     if args.output is not None and os.path.isfile(args.output):
    #         print("Error: --output must be a directory for batch mode, not a file")
    #         sys.exit(1)
    #     reproduce_all_frames(args.dir, args.output, args.pattern, show_plot=args.show)
    # else:
    #     print("Error: Must specify either --npz (single file) or --dir (batch mode)")
    #     parser.print_help()
    #     sys.exit(1)


if __name__ == "__main__":
    main()

